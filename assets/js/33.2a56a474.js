(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{383:function(v,_,t){"use strict";t.r(_);var e=t(42),a=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"react-vs-vue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-vs-vue"}},[v._v("#")]),v._v(" React-vs-Vue")]),v._v(" "),t("blockquote",[t("p",[v._v("待完善")])]),v._v(" "),t("p",[v._v("共同点：")]),v._v(" "),t("ol",[t("li",[v._v("都使用了虚拟DOM")]),v._v(" "),t("li",[v._v("都提供了数据改变 -> 重新渲染的响应式系统")]),v._v(" "),t("li",[v._v("两者都是异步更新DOM，React中使用"),t("code",[v._v("setState")]),v._v("时不会立刻更新数据，而是加入缓存队列中，批量更新数据之后再渲染DOM；Vue中可以直接修改数据，但此时并不会直接渲染DOM，同样要加入缓存队列，再渲染DOM。")])]),v._v(" "),t("p",[v._v("不同点：")]),v._v(" "),t("ol",[t("li",[v._v("Vue中，只有纳入响应式系统的属性的值改变了（新增属性，或者依赖没有被收集的属性不算纳入响应式系统中），才会重新渲染；而React只要通过"),t("code",[v._v("setState")]),v._v("操作了数据，就会重新渲染")]),v._v(" "),t("li",[v._v("Vue中，只有数据（"),t("code",[v._v("state")]),v._v("和"),t("code",[v._v("props")]),v._v("）改变时才会重新渲染；React中，对于非纯组件，如果父组件重新渲染，那么子资源也会重新渲染")]),v._v(" "),t("li",[v._v("Vue组件通常需要提前规定好"),t("code",[v._v("props")]),v._v("，而"),t("code",[v._v("react")]),v._v("不用；Vue当传递给组件一个非"),t("code",[v._v("props")]),v._v("的值，会自动挂载给组件的根元素（对于多个元素需要使用"),t("code",[v._v("$attr")]),v._v("），而"),t("code",[v._v("React")]),v._v("并不会。")])]),v._v(" "),t("h3",{attrs:{id:"虚拟dom"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[v._v("#")]),v._v(" 虚拟DOM")]),v._v(" "),t("p",[v._v("虚拟DOM（VNode），可以粗略地把它理解为一个用来表示真实DOM树的JS对象。")]),v._v(" "),t("p",[v._v("无论Vue还是React，虚拟DOM都是通过数据和渲染函数生成的，对于Vue来说渲染函数是通过模板编译而来的。")]),v._v(" "),t("p",[v._v("第一次生成VNode时，会根据VNode来生成页面，也就是所谓的挂载。")]),v._v(" "),t("p",[v._v("之后当数据改变时，就会重新根据数据和渲染函数生成一个新的VNode。之后使用Diff算法来找出先后两个VNode之间的差异，并自动地对真实DOM进行操作。")]),v._v(" "),t("h5",{attrs:{id:"虚拟dom的优劣"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom的优劣"}},[v._v("#")]),v._v(" 虚拟DOM的优劣")]),v._v(" "),t("p",[v._v("在框架前的时代，无论是用原生代码还是使用类似"),t("code",[v._v("JQuery")]),v._v("的类库，我们都是在直接操作真实DOM。")]),v._v(" "),t("p",[v._v("框架后时代，我们只需要操作数据，框架就会帮我们来操作真实DOM")]),v._v(" "),t("p",[t("strong",[v._v("优点")])]),v._v(" "),t("ol",[t("li",[t("p",[v._v("保证性能的下限。")]),v._v(" "),t("p",[v._v("当我们使用虚拟DOM的时候，框架会帮我们完成DOM的操作，相当于是一个自动化的过程。")]),v._v(" "),t("p",[v._v("想一想，一个前端菜鸟随便对真实DOM进行操作，一不小心就会写出低性能的代码。而当我们使用虚拟DOM，类似把我们的需求告诉我们的框架底层，让其进行真实DOM的操作。")])]),v._v(" "),t("li",[t("p",[v._v("跨平台。")]),v._v(" "),t("p",[v._v("虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。")])])]),v._v(" "),t("p",[t("strong",[v._v("缺点")])]),v._v(" "),t("ol",[t("li",[v._v("虚拟DOM的使用可以保证性能的下限，但也正是因为如此，它也无法做到极致的优化。毕竟，我们操作虚拟DOM的最终目的是操作真实DOM，那论性能的上限自然是无法与直接操作真实DOM相比。")])]),v._v(" "),t("h3",{attrs:{id:"单页-多页应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单页-多页应用"}},[v._v("#")]),v._v(" 单页/多页应用")]),v._v(" "),t("blockquote",[t("p",[v._v("不要吐槽为什么这一节放在vue/react区别下面...")])]),v._v(" "),t("h5",{attrs:{id:"单页应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单页应用"}},[v._v("#")]),v._v(" 单页应用")]),v._v(" "),t("p",[v._v("优点：")]),v._v(" "),t("ol",[t("li",[v._v("前后端分离")]),v._v(" "),t("li",[v._v("页面的切换流畅。")])]),v._v(" "),t("p",[v._v("缺点：")]),v._v(" "),t("ol",[t("li",[v._v("首屏加载慢，容易出现首屏白屏的情况")]),v._v(" "),t("li",[v._v("对SEO不友好")])]),v._v(" "),t("h5",{attrs:{id:"多页应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多页应用"}},[v._v("#")]),v._v(" 多页应用")]),v._v(" "),t("p",[v._v("好处")]),v._v(" "),t("ol",[t("li",[v._v("首屏加载快")]),v._v(" "),t("li",[v._v("对SEO友好")])]),v._v(" "),t("p",[v._v("坏处")]),v._v(" "),t("ol",[t("li",[v._v("页面的切换不流畅。")])]),v._v(" "),t("h5",{attrs:{id:"服务端渲染-ssr"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染-ssr"}},[v._v("#")]),v._v(" 服务端渲染/SSR")]),v._v(" "),t("blockquote",[t("p",[v._v("笔者对SSR并没怎么接触，建议读者跳过该节的内容，目标只是稍微做一个笔记，并不代表严谨和正确。")])]),v._v(" "),t("p",[v._v("单页应用的两大缺点，首屏加载和SEO不友好。对于前者，我们通常有类似"),t("strong",[v._v("路由懒加载")]),v._v("，或者是"),t("strong",[v._v("骨架屏")]),v._v("之类的解决方案；对于后者，谷歌的"),t("strong",[v._v("puppeteer")]),v._v("似乎也是可以一定程度上解决的（只听闻过，未曾了解），puppeteer对我们SPA应用进行爬取，然后渲染出html，后端对请求进行判断，如果是爬虫请求，就将我们就走puppeteer渲染的服务器，如果是用户就直接走单页就好了。")]),v._v(" "),t("p",[t("strong",[v._v("服务端渲染")]),v._v("也是用来解决单页应用的缺点的，当然，虽然可以一定程度上解决，开发的成本也会相应的提高。")]),v._v(" "),t("p",[v._v("目前我对服务端渲染了解的还不深，只能说大概的目标是通过在服务端渲染出HTML发送给浏览器，取代原本的：浏览器中执行JS代码生成完整的HTML。这样，爬虫就可以爬到完整的网页；不过服务端渲染也会提高服务器的开销。")]),v._v(" "),t("p",[v._v("通常的单页应用采取的是客户端渲染的方式。用户访问网站时通常只获取一个"),t("code",[v._v("<div id='app'></div>")]),v._v("，之后在浏览器中执行JS代码，生成完整的网页。而搜索引擎爬虫爬到网页后并不会执行JS代码，因此无法爬到网页的文本。")]),v._v(" "),t("p",[v._v("服务端渲染大概的目标是在服务端渲染网页再发送给前端，不过在解决前端SEO的问题的同时，也会给服务器带来额外的开销。")]),v._v(" "),t("p",[v._v("同构：指的是同一份代码，既可以跑在前端，也可以跑在后端。")])])}),[],!1,null,null,null);_.default=a.exports}}]);